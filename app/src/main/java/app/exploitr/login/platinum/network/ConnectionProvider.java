package app.exploitr.login.platinum.network;

import android.util.Log;

import androidx.annotation.Nullable;

import java.io.IOException;
import java.util.concurrent.TimeUnit;

import app.exploitr.login.platinum.helpers.Constants;
import app.exploitr.login.platinum.models.ISPDataModel;
import app.exploitr.login.platinum.models.UserDataModel;
import okhttp3.FormBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

public class ConnectionProvider {

    /*
     * Attempts to login with models then returns result based on if internet connection is actually successful or not
     * we will also return local error codes which will be best guesses based on situations to show the user
     *
     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses -> using 200-299 verification range
     * */
    public static void connectToInternet(ISPDataModel i_model, UserDataModel u_model, ConnectionVerifyListener listener) {
        tryLogin(i_model, u_model, new ConnectionListener() {
            @Override
            public void onResponse(int code) {
                if (code >= 200 && code <= 299) {
                    isSuccessFullyConnected(listener);
                } else {
                    listener.onFailure(new IOException("login error -> connectToLogin() -> tryLogin()"));
                }
            }

            @Override
            public void onFailure(@Nullable Exception e) {
                listener.onFailure(e);
            }
        });
    }

    /*
     * Attempts to login with models then returns result based on if internet connection is actually successful or not
     * we will also return local error codes which will be best guesses based on situations to show the user
     * */
    public static void disconnectFromInternet(ISPDataModel i_model, UserDataModel u_model, DisconnectionVerifyListener listener) {
        tryLogout(i_model, u_model, new ConnectionListener() {
            @Override
            public void onResponse(int code) {
                if (code >= 200 && code <= 299) {
                    isSuccessFullyConnected(new ConnectionVerifyListener() {
                        @Override
                        public void onSuccess() {
                            listener.onFailure(new IllegalStateException("Couldn't log out : disconnectFromInternet() -> onResponse() -> onSuccess()"));
                        }

                        @Override
                        public void onFailure(@Nullable Exception e) {
                            listener.onSuccess();
                        }
                    });
                } else {
                    listener.onSuccess();
                }
            }

            @Override
            public void onFailure(@Nullable Exception e) {
                // idk? maybe still it can disconnect, I mean a failed request? that's how okhttp perceives it?
                isSuccessFullyConnected(new ConnectionVerifyListener() {
                    @Override
                    public void onSuccess() {
                        listener.onFailure(new IllegalStateException("Couldn't log out : disconnectFromInternet() -> onFailure()"));
                    }

                    @Override
                    public void onFailure(@Nullable Exception e) {
                        listener.onSuccess();
                    }
                });
            }
        });
    }

    /*
     * Performs logout action with models
     */
    private static void tryLogout(ISPDataModel i_model, UserDataModel u_model, ConnectionListener listener) {
        new Thread(() -> {
            OkHttpClient client = new OkHttpClient()
                    .newBuilder()
                    .connectTimeout(10, TimeUnit.SECONDS)
                    .build();

            var builder = new Request.Builder()
                    .url(i_model.getLogoutAddress());
            if (i_model.getLogoutHeaders().size() > 0) {
                for (var head : u_model.getLogoutHeaders()) {
                    builder.addHeader(head.getKey(), head.getValue());
                }
            }

            var reqBodyBuilder = new FormBody.Builder();
            for (var arg : u_model.getLogoutArguments()) {
                reqBodyBuilder.add(arg.getKey(), arg.getValue());
            }

            var reqBody = reqBodyBuilder.build();
            Log.d(Constants.DEBUG_TAG, "Request body : tryLogout() -> " + reqBody.toString());
            Request request;

            // https://stackoverflow.com/a/983458 : The RFC2616 referenced as "HTTP/1.1 spec" is now obsolete.
            // In 2014 it was replaced by RFCs 7230-7237. Quote "the message-body SHOULD be ignored when handling the request" has been deleted.
            // It's now just "Request message framing is independent of method semantics, even if the method doesn't define any use for a message body"
            // The 2nd quote "The GET method means retrieve whatever information ... is identified by the Request-URI" was deleted.
            if (i_model.getRequestTypeLogin() == ISPDataModel.REQUEST_TYPE_GET) {
                builder.put(reqBody);
                request = builder.get().build();
            } else {
                request = builder.post(reqBody).build();
            }

            try (Response response = client.newCall(request).execute()) {
                listener.onResponse(response.code());
            } catch (IOException e) {
                listener.onFailure(e);
            }
        }).start();
    }

    /*
     * Performs login action with models
     */
    private static void tryLogin(ISPDataModel i_model, UserDataModel u_model, ConnectionListener listener) {
        new Thread(() -> {
            OkHttpClient client = new OkHttpClient()
                    .newBuilder()
                    .connectTimeout(10, TimeUnit.SECONDS)
                    .build();

            var builder = new Request.Builder()
                    .url(i_model.getLoginAddress());
            if (i_model.getLoginHeaders().size() > 0) {
                for (var head : u_model.getLoginHeaders()) {
                    builder.addHeader(head.getKey(), head.getValue());
                }
            }

            var reqBodyBuilder = new FormBody.Builder();
            for (var arg : u_model.getLoginArguments()) {
                reqBodyBuilder.add(arg.getKey(), arg.getValue());
            }

            var reqBody = reqBodyBuilder.build();
            Log.d(Constants.DEBUG_TAG, "Request body : tryLogin() -> " + reqBody.toString());
            Request request;

            // https://stackoverflow.com/a/983458 : The RFC2616 referenced as "HTTP/1.1 spec" is now obsolete.
            // In 2014 it was replaced by RFCs 7230-7237. Quote "the message-body SHOULD be ignored when handling the request" has been deleted.
            // It's now just "Request message framing is independent of method semantics, even if the method doesn't define any use for a message body"
            // The 2nd quote "The GET method means retrieve whatever information ... is identified by the Request-URI" was deleted.
            if (i_model.getRequestTypeLogin() == ISPDataModel.REQUEST_TYPE_GET) {
                builder.put(reqBody);
                request = builder.get().build();
            } else {
                request = builder.post(reqBody).build();
            }

            try (Response response = client.newCall(request).execute()) {
                listener.onResponse(response.code());
            } catch (IOException e) {
                listener.onFailure(e);
            }
        }).start();
    }

    /*
     * As observed with several ISPs, ping test doesn't suffice anymore and is incorrect and unstable
     * so we'll try to load an webpage / download small file to confirm connection!
     * In case of webpage loading, some isp-s redirect to login page,
     * disabling redirect in okhttp will suffice? -> I'm not sure.
     * so, we will try to download a small file instead I guess?
     * */
    public static void isSuccessFullyConnected(ConnectionVerifyListener listener) {
        new Thread(() -> {
            OkHttpClient client = new OkHttpClient()
                    .newBuilder()
                    .followRedirects(false)
                    .followSslRedirects(false)
                    .connectTimeout(3, TimeUnit.SECONDS)
                    .build();

            var request = new Request.Builder()
                    .url("https://www.google.com/")
                    .get().build();

            var requestForGoogleLogo = new Request.Builder()
                    .url("https://www.google.ca/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png")
                    .get().build();

            try (Response response = client.newCall(request).execute()) {
                try (Response n_response = client.newCall(requestForGoogleLogo).execute()) {
                    var body = n_response.body();
                    if (body == null) {
                        listener.onFailure(new IOException("Response body null :: testConnectionWithOkHttp()"));
                        return;
                    }
                    Log.d(Constants.DEBUG_TAG, "Connection testing : Webpage -> " + response.code() + " ; "
                            + "Image ->" + n_response.code() + " : " + n_response.body().contentLength());
                    if (body.contentLength() > 0 && response.code() >= 200 && response.code() <= 399 && n_response.code() >= 200 && n_response.code() <= 399) {
                        listener.onSuccess();
                    }
                }
            } catch (IOException e) {
                listener.onFailure(e);
            }
        }).start();
    }

    private interface ConnectionListener {
        void onResponse(int code);

        void onFailure(@Nullable Exception e);
    }

    public interface ConnectionVerifyListener {
        void onSuccess();

        void onFailure(@Nullable Exception e);
    }

    public interface DisconnectionVerifyListener {
        void onSuccess();

        void onFailure(@Nullable Exception e);
    }
}
