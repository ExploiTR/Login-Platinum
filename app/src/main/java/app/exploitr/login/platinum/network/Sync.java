package app.exploitr.login.platinum.network;

import android.content.Context;
import android.net.Uri;
import android.widget.Toast;

import androidx.annotation.NonNull;

import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.Task;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.UserProfileChangeRequest;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.QueryDocumentSnapshot;
import com.google.firebase.firestore.QuerySnapshot;

import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nullable;

import app.exploitr.login.platinum.database.UserProfileDB;
import app.exploitr.login.platinum.models.ISPDataModel;
import app.exploitr.login.platinum.models.RealmController;
import app.exploitr.login.platinum.models.UserDataModel;

public class Sync {
    private static SyncListener listener;
    private static int internal_progress = 0;
    private static boolean syncIsp = false;
    private static boolean syncUserConfigs = false;
    private static boolean syncJoiningDate = false;
    private static boolean syncUserProfile = false;

    static String ISP_PROFILE_NAME = "isp_profile_name";
    static String ISP_PROFILE_LOGIN_ADDRESS = "isp_profile_login_address";
    static String ISP_PROFILE_LOGOUT_ADDRESS = "isp_profile_logout_address";
    static String ISP_PROFILE_LOGIN_REQ_TYPE = "isp_profile_login_request_type";
    static String ISP_PROFILE_LOGOUT_REQ_TYPE = "isp_profile_logout_request_type";
    static String ISP_PROFILE_LOGIN_ARGS = "isp_profile_login_arguments";
    static String ISP_PROFILE_LOGIN_HEADERS = "isp_profile_login_headers";
    static String ISP_PROFILE_LOGOUT_ARGS = "isp_profile_logout_arguments";
    static String ISP_PROFILE_LOGOUT_HEADERS = "isp_profile_logout_headers";
    static String USER_PROFILE_NAME = "user_profile_name";
    static String ISP_PROFILE_ASSOCIATED = "isp_profile_assoc";

    public static void sync(Context context, SyncListener _listener) {
        checkVersion(context);
        listener = _listener;
    }

    /*
     * todo : filter exception for folder not existing and connection error, must not be confused
     * compares local version against remote version and decides which method to run between upload and download
     * */
    static void checkVersion(Context con) {
        long val = new UserProfileDB(con).getVersion();
        FireDataProvider.download(FireDataProvider.userDataDocument(FirebaseAuth.getInstance().getCurrentUser().getUid()), new FireDataProvider.FireDataListenerForDocuments() {
            @Override
            public void onSuccess(DocumentSnapshot data) {
                long val_c = (long) data.get(FireDataProvider.FIRE_USER_DATA_VERSION);
                if (val_c > val) {
                    downloadInternal(con);
                } else {
                    uploadInternal(con);
                }
            }

            @Override
            public void onFail(Exception e) {
                uploadInternal(con);
            }
        });
    }

    private static void downloadInternal(Context context) {
        DownloadMethods.downloadIspConfigurations(context);
        DownloadMethods.downloadUserConfigurations(context);
        DownloadMethods.downloadUserInfo(context);
    }

    private static void uploadInternal(Context con) {
        UploadMethods.uploadIspConfigurations(con);
        UploadMethods.uploadUserConfigurations(con);
        UploadMethods.uploadUserInfo(con);
    }

    private static void update(Context context) {
        listener.onProgress(Math.min(internal_progress, 95));

        if (syncUserConfigs && syncUserProfile && syncIsp && syncJoiningDate) {
            UserProfileDB usr = new UserProfileDB(context);
            var v = usr.getVersion();
            SyncHelper.updateRemoteVersion(new SyncHelper.VersionUpdateListener() {
                @Override
                public void update(long version) {
                    usr.updateVersion(version);
                }

                @Override
                public void onFail() {
                    Toast.makeText(context, "Sync successful! (Error accessing remote version details)", Toast.LENGTH_LONG).show();
                }
            });
            listener.onSyncComplete(); //done!
        }
    }

    private static class DownloadMethods {
        static void downloadUserInfo(Context context) {
            downloadJoiningDate(context);
            downloadUserProfile(context);
        }

        static void downloadUserProfile(Context context) {
            var account = FirebaseAuth.getInstance().getCurrentUser();
            var profile = new UserProfileDB(context);
            if (account == null || account.getDisplayName() == null) {
                syncUserProfile = true;
                return;
            }
            profile.setUsername(account.getDisplayName());

            Uri ph_uri;
            if ((ph_uri = account.getPhotoUrl()) != null) {
                profile.setProfileUrl(ph_uri.toString());
            }
            syncUserProfile = true;
            update(context);
        }

        static void downloadJoiningDate(Context context) {
            var account = FirebaseAuth.getInstance().getCurrentUser();
            var profile = new UserProfileDB(context);
            FireDataProvider.download(FireDataProvider.userDataDocument(
                            FirebaseAuth.getInstance().getCurrentUser().getUid()),
                    new FireDataProvider.FireDataListenerForDocuments() {
                        @Override
                        public void onSuccess(DocumentSnapshot data) {
                            if (data.exists()) {
                                profile.setJoiningDate(data.getLong(FireDataProvider.FIRE_USER_DATA_JOINING_DATE));
                            } else {
                                profile.setJoiningDate(System.currentTimeMillis());
                            }
                            syncJoiningDate = true;
                            update(context);
                        }

                        @Override
                        public void onFail(Exception e) {
                            Toast.makeText(context, "Couldn't load partial userdata.", Toast.LENGTH_SHORT).show();
                            profile.setJoiningDate(System.currentTimeMillis());
                            syncJoiningDate = true;
                            update(context);
                        }
                    });
        }

        static void downloadIspConfigurations(Context context) {
            var isp = FireDataProvider.userDataIspList(FirebaseAuth.getInstance().getCurrentUser().getUid());
            isp.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                @Override
                public void onComplete(@NonNull Task<QuerySnapshot> task) {
                    if (task.isSuccessful()) {
                        if (task.getResult() == null || task.getResult().isEmpty()) {
                            return;
                        }
                        for (QueryDocumentSnapshot document : task.getResult()) {
                            RealmController.getInstance().updateIspProfile(document.toObject(ISPDataModel.class));
                            internal_progress += 1;
                            update(context);
                        }
                        internal_progress += 5;
                        update(context);
                    } else {
                        Toast.makeText(context, "Failed to sync partial data!, retry later.", Toast.LENGTH_SHORT).show();
                    }
                    syncIsp = true; //no matter what we cant stall the app
                }
            });
        }

        static void downloadUserConfigurations(Context context) {
            var user = FireDataProvider.userDataUserConfigList(FirebaseAuth.getInstance().getCurrentUser().getUid());
            user.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                @Override
                public void onComplete(@NonNull Task<QuerySnapshot> task) {
                    if (task.isSuccessful()) {
                        if (task.getResult() == null || task.getResult().isEmpty()) {
                            return;
                        }
                        for (QueryDocumentSnapshot document : task.getResult()) {
                            RealmController.getInstance().updateUserProfile(document.toObject(UserDataModel.class));
                            internal_progress += 1;
                            update(context);
                        }
                        internal_progress += 5;
                        update(context);
                    } else {
                        Toast.makeText(context, "Failed to sync partial data!, retry later.", Toast.LENGTH_SHORT).show();
                    }
                    syncUserConfigs = true;
                }
            });
        }
    }

    private static class UploadMethods {
        static void uploadUserInfo(Context context) {
            uploadJoiningDate(context);
            uploadUserProfile(context);
        }

        static void uploadUserProfile(Context context) {
            var account = FirebaseAuth.getInstance().getCurrentUser();
            var profile = new UserProfileDB(context);
            account.updateProfile(new UserProfileChangeRequest.Builder()
                    .setDisplayName(profile.getUsername())
                    .setPhotoUri(Uri.parse(profile.getProfileUrl())).build());
            syncUserProfile = true;
            update(context);
        }

        static void uploadJoiningDate(Context context) {
            var account = FirebaseAuth.getInstance().getCurrentUser();
            var profile = new UserProfileDB(context);
            Map<String, Object> var = new HashMap<>();
            var.put(FireDataProvider.FIRE_USER_DATA_JOINING_DATE, profile.getJoiningDate());
            FireDataProvider.userDataDocument(
                            FirebaseAuth.getInstance().getCurrentUser().getUid())
                    .set(var).addOnCompleteListener(new OnCompleteListener<Void>() {
                        @Override
                        public void onComplete(@NonNull Task<Void> task) {
                            if (!task.isSuccessful()) {
                                Toast.makeText(context, "Couldn't load partial userdata.", Toast.LENGTH_SHORT).show();
                            }
                            syncJoiningDate = true;
                            update(context);
                        }
                    });
        }

        /*
         * Takes the total local list compares against remote list then uploads
         * the ones which are mutable and tested, same goes for the other method used
         * for user configurations
         * */
        static void uploadIspConfigurations(Context context) {
            var all_isp = RealmController.getInstance().getIspProfileList();
            var isp_r = FireDataProvider.userDataIspList(FirebaseAuth.getInstance().getCurrentUser().getUid());

            isp_r.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                @Override
                public void onComplete(@NonNull Task<QuerySnapshot> task) {
                    if (task.isSuccessful()) {
                        for (var isp_l : all_isp) {
                            if (isp_l.isImmutable() || !isp_l.isTested()) //filter pre-existing configs and those who are not tested yet successfully
                                continue;
                            boolean contains = false; //we check if already entry present in server
                            for (var isp : task.getResult()) {
                                if (isp.getId().trim().equalsIgnoreCase(String.valueOf(isp_l.getIsp_profile_id()).trim())) {
                                    //we trim cause we don't want mishaps
                                    contains = true;
                                    break;
                                }
                            }
                            if (!contains) { //only add if entry doesn't contain in server
                                SyncHelper.uploadIspConfig(isp_l, isp_r, new SyncHelper.SyncHelperListener() {
                                    @Override
                                    public void onJobDone(Task<Void> task) {
                                        if (all_isp.indexOf(isp_l) == all_isp.size() - 1) {
                                            syncIsp = true;
                                            update(context);
                                        }
                                    }
                                });
                            } else {
                                if (all_isp.indexOf(isp_l) == all_isp.size() - 1) {
                                    syncIsp = true;
                                    update(context);
                                }
                            }
                        }
                    } else {
                        syncIsp = true;
                        update(context);
                    }
                }
            });
        }

        static void uploadUserConfigurations(Context context) {
            var all_users = RealmController.getInstance().getUserProfileList();
            var users_r = FireDataProvider.userDataUserConfigList(FirebaseAuth.getInstance().getCurrentUser().getUid());

            users_r.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                @Override
                public void onComplete(@NonNull Task<QuerySnapshot> task) {
                    if (task.isSuccessful()) {
                        for (var usr_l : all_users) {
                            if (!usr_l.isTested()) //filter untested configs
                                continue;
                            boolean contains = false; //we check if already entry present in server
                            for (var isp : task.getResult()) {
                                if (isp.getId().trim().equalsIgnoreCase(String.valueOf(usr_l.getProfile_id()).trim())) {
                                    //we trim cause we don't want mishaps
                                    contains = true;
                                    break;
                                }
                            }
                            if (!contains) { //only add if entry doesn't contain in server
                                SyncHelper.uploadUserConfig(usr_l, users_r, new SyncHelper.SyncHelperListener() {
                                    @Override
                                    public void onJobDone(Task<Void> task) {
                                        if (all_users.indexOf(usr_l) == all_users.size() - 1) {
                                            syncIsp = true;
                                            update(context);
                                        }
                                    }
                                });
                            } else {
                                if (all_users.indexOf(usr_l) == all_users.size() - 1) {
                                    syncIsp = true;
                                    update(context);
                                }
                            }
                        }
                    } else {
                        syncUserConfigs = true;
                        update(context);
                    }
                }
            });
        }
    }

    public interface SyncListener {
        void onSyncComplete();

        void onProgress(int progress);

        void onSyncFail(@Nullable Exception e);
    }
}
